<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carta Única Flip/Rotate con Partículas</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a0033, #4a148c, #3f51b5);
            min-height: 100vh;
            overflow: hidden; /* Importante para que las partículas no generen scroll */
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Para posicionar botón flip y canvas */
            user-select: none; /* Evitar selección */
            -webkit-user-select: none;
        }

        .card-container {
            width: 80vw;
            height: auto; /* Altura automática basada en proporción */
            aspect-ratio: 300 / 420; /* Proporción carta (ancho / alto) */
            max-width: 300px; /* Ancho máximo */
            position: relative;
            perspective: 1000px; /* Perspectiva para efecto 3D */
            cursor: grab; /* Cursor para indicar que se puede arrastrar */
            user-select: none;
            -webkit-user-drag: none;
            z-index: 10; /* Asegurar que la carta esté sobre el canvas */
        }
        .card-container:active {
             cursor: grabbing;
        }

        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            /* La transición se aplica/quita con JS para evitar conflictos */
            transition: none;
            transform: rotateX(0deg) rotateY(0deg); /* Estado inicial */
            user-select: none;
            -webkit-user-drag: none;
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; /* Oculta la cara trasera por defecto */
            border-radius: 8px;
            overflow: hidden; /* Asegura que contenido no se salga */
            /* background-color añadido por si las imágenes no cargan */
            background-color: #555;
            display: block; /* Resetear flex si no es necesario */
             user-select: none;
             -webkit-user-drag: none;
        }

        .card-face img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none;
            user-select: none;
            -webkit-user-drag: none;
        }

        .card-face.front {
            /* Estilos específicos del frente si los hubiera */
        }

        .card-face.back {
            transform: rotateY(180deg); /* Posiciona la cara trasera girada */
            background-color: #333; /* Fondo oscuro para la parte trasera */
            position: relative; /* Para posicionar botones dentro */
        }

        /* Estilos para botones DENTRO de .card-face.back */
        .card-face.back .youtube-button {
             background-color: red;
             border: none;
             padding: 8px 12px;
             border-radius: 5px;
             cursor: pointer;
             position: absolute;
             z-index: 1; /* Encima de la imagen de fondo de la cara */
             color: white;
             font-family: Arial, sans-serif;
             font-weight: bold;
             transition: background 0.3s;
             top: 20px;
             left: 20px;
        }
         .card-face.back .youtube-button:hover {
            background-color: darkred;
         }
         .card-face.back .social-icons {
             position: absolute;
             bottom: 10px;
             right: 10px;
             display: flex;
             gap: 10px;
             z-index: 1;
         }
         .card-face.back .social-icons a {
             color: white;
             text-decoration: none;
             font-size: 24px;
             transition: color 0.3s;
         }
         .card-face.back .social-icons a:hover {
             color: #8c9eff;
         }

        /* Botón de Voltear General (fuera de la carta) */
        .flip-button {
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.3s, transform 0.3s;
            position: absolute;
            z-index: 100;
            bottom: 30px;
            right: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         .flip-button:hover {
            background-color: white;
            transform: scale(1.1);
         }

        canvas#particleCanvas { /* Selector más específico */
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             pointer-events: none;
             z-index: 0; /* Detrás del card-container */
         }

         /* Media query básica */
         @media (max-width: 600px) {
             .card-container { max-width: 90vw; }
             .flip-button { width: 40px; height: 40px; bottom: 20px; right: 20px;}
             .card-face.back .youtube-button { padding: 6px 10px; font-size: 12px; top: 15px; left: 15px; }
             .card-face.back .social-icons { bottom: 8px; right: 8px; gap: 8px;}
             .card-face.back .social-icons a { font-size: 18px; }
         }

    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>

    <div class="card-container" id="cardContainer">
        <div class="card" id="interactiveCard">
            <div class="card-face front">
                <img src="carta_frente.png.jpg" alt="Frente de la Carta">
            </div>
            <div class="card-face back">
                 <img src="carta_dorso.png.png" alt="Dorso de la Carta">
                <button class="youtube-button" onclick="window.open('googleusercontent.com/youtube.com/4', '_blank')">
                    <i class="fab fa-youtube"></i> YouTube
                </button>
                <div class="social-icons">
                    <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
                    <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
                    <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
                </div>
            </div>
        </div>
    </div>

    <button class="flip-button" id="flipButton">
        <i class="fas fa-sync-alt" style="color: #333; font-size: 18px;"></i>
    </button>

    <script>
        // --- VARIABLES GLOBALES ---
        const cardContainer = document.getElementById('cardContainer');
        const cardElement = document.getElementById('interactiveCard');
        const flipButton = document.getElementById('flipButton');
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const particles = [];
        const numParticles = 50;

        let isDragging = false;
        let startX, startY, currentX, currentY;
        let dragRotationX = 0; // Rotación actual por arrastre en X
        let dragRotationY = 0; // Rotación actual por arrastre en Y
        let isFlipping = false;
        let currentFlipRotation = 0; // Grados actuales del volteo (0, 180, 360...)
        const rotationFactor = 0.4; // Sensibilidad del arrastre

        // Variables para física de rebote
        let velocityX = 0;
        let velocityY = 0;
        const friction = 0.92;
        const springForce = 0.04;
        let animationFrameId = null;

        // --- LÓGICA DE VOLTEO (FLIP) ---
        flipButton.addEventListener('click', () => {
            if (isFlipping || isDragging) return;

            isFlipping = true;
            disableDrag(); // Desactivar arrastre mientras voltea
            cancelAnimationFrame(animationFrameId); // Detener animación de rebote

            currentFlipRotation += 180; // Calcular rotación final

            // Aplicar volteo usando transición CSS
            cardElement.style.transition = 'transform 0.6s ease-in-out';
            cardElement.style.transform = `rotateY(${currentFlipRotation}deg) rotateX(0deg)`; // Resetear X

            cardElement.addEventListener('transitionend', onFlipEnd, { once: true });
        });

        function onFlipEnd() {
            isFlipping = false;
            // Quitar transición para que el drag sea inmediato
            // La transición se quitará en handleDragStart si se inicia drag
            // o se pondrá en handleDragEnd para el rebote
            dragRotationX = 0; // Resetear drag al terminar flip
            dragRotationY = 0;
            velocityX = 0;
            velocityY = 0;
            enableDrag(); // Reactivar arrastre
        }

        // --- LÓGICA DE ROTACIÓN INTERACTIVA (DRAG) ---
        function handleDragStart(e) {
            if (isFlipping) return;
            isDragging = true;
            cardContainer.style.cursor = 'grabbing';
            cardElement.style.transition = 'none'; // Quitar transición para drag manual
            cancelAnimationFrame(animationFrameId); // Detener animación si la había

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = cardContainer.getBoundingClientRect();
            startX = clientX - (rect.left + rect.width / 2);
            startY = clientY - (rect.top + rect.height / 2);

            // Resetear velocidades y drag al iniciar nuevo drag
            velocityX = 0;
            velocityY = 0;
            // No reseteamos dragRotationX/Y aquí para continuar desde donde estaba?
            // Depende del feel deseado. Vamos a resetearlo para que cada drag empiece desde 0 offset.
            // dragRotationX = 0; // Comentado - permite drag acumulativo si se suelta y agarra rápido
            // dragRotationY = 0; // Comentado

            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchend', handleDragEnd);
            document.addEventListener('mouseleave', handleDragEnd); // Importante por si sale de la ventana
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            if (e.touches) e.preventDefault(); // Evitar scroll en táctil

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = cardContainer.getBoundingClientRect();
            currentX = clientX - (rect.left + rect.width / 2);
            currentY = clientY - (rect.top + rect.height / 2);

            const deltaX = currentX - startX;
            const deltaY = currentY - startY;

            // Acumular rotación por drag
            // La rotación ahora es relativa al inicio del drag actual
            dragRotationY = deltaX * rotationFactor;
            dragRotationX = -deltaY * rotationFactor;

            // Limitar rotación por drag
            dragRotationX = Math.max(-60, Math.min(60, dragRotationX));
            dragRotationY = Math.max(-80, Math.min(80, dragRotationY));

            // Guardar velocidad para inercia (basada en el último delta)
            velocityX = -deltaY * 0.5;
            velocityY = deltaX * 0.5;

            // Aplicar transformación combinada: Flip + Drag
            cardElement.style.transform = `rotateY(${currentFlipRotation + dragRotationY}deg) rotateX(${dragRotationX}deg)`;

            // NO actualizamos startX/startY para que el delta sea siempre desde el inicio del drag actual
        }

        function handleDragEnd() {
            if (!isDragging) return;
            isDragging = false;
            cardContainer.style.cursor = 'grab';

            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('touchend', handleDragEnd);
            document.removeEventListener('mouseleave', handleDragEnd);

            // Iniciar animación de rebote/inercia si hay velocidad o desviación
             if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1 || Math.abs(dragRotationX) > 0.1 || Math.abs(dragRotationY) > 0.1) {
                 animateRebound();
             } else {
                 // Si no hay velocidad ni desviación, asegurar centro (sin drag)
                 cardElement.style.transition = 'transform 0.4s ease-out';
                 cardElement.style.transform = `rotateY(${currentFlipRotation}deg) rotateX(0deg)`;
                 setTimeout(() => { if (!isFlipping) cardElement.style.transition = 'none'; }, 400);
             }
        }

        // --- Animación de Rebote/Inercia ---
        function animateRebound() {
            if (isDragging || isFlipping) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                return; // Detener si hay interacción
            }

            // Aplicar inercia
            dragRotationY += velocityY;
            dragRotationX += velocityX;

            // Aplicar fricción
            velocityY *= friction;
            velocityX *= friction;

            // Aplicar fuerza de resorte hacia 0 drag
            const forceY = -dragRotationY * springForce;
            const forceX = -dragRotationX * springForce;
            velocityY += forceY;
            velocityX += forceX;

            // Limitar
            dragRotationX = Math.max(-90, Math.min(90, dragRotationX));
            dragRotationY = Math.max(-90, Math.min(90, dragRotationY));

            // Aplicar transformación
             cardElement.style.transition = 'none'; // Asegurar que no haya transición CSS durante anim JS
            cardElement.style.transform = `rotateY(${currentFlipRotation + dragRotationY}deg) rotateX(${dragRotationX}deg)`;

            // Condición de parada
            if (Math.abs(velocityY) > 0.01 || Math.abs(velocityX) > 0.01 || Math.abs(dragRotationY) > 0.01 || Math.abs(dragRotationX) > 0.01) {
                animationFrameId = requestAnimationFrame(animateRebound);
            } else {
                // Asegurar estado final
                dragRotationX = 0; dragRotationY = 0; velocityX = 0; velocityY = 0;
                cardElement.style.transform = `rotateY(${currentFlipRotation}deg) rotateX(0deg)`;
                animationFrameId = null;
            }
        }

        // Funciones para activar/desactivar drag
        function enableDrag() {
            cardContainer.addEventListener('mousedown', handleDragStart);
            cardContainer.addEventListener('touchstart', handleDragStart, { passive: false });
           // console.log("Drag Activado");
        }

        function disableDrag() {
            cardContainer.removeEventListener('mousedown', handleDragStart);
            cardContainer.removeEventListener('touchstart', handleDragStart);
            // Limpiar listeners de documento si se interrumpe un drag
            if(isDragging) {
                 handleDragEnd(); // Llama a fin para limpiar listeners y estado
            }
           // console.log("Drag Desactivado");
        }

        // Activar drag inicialmente
        enableDrag();


        // --- Lógica Partículas ---
         const numParticles = 50;

         class Particle {
             constructor(x, y) {
                 this.x = x; this.y = y;
                 this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.5;
                 this.radius = Math.random() * 1.5 + 0.5;
                 const shapeRand = Math.random();
                 this.shape = shapeRand < 0.7 ? 'circle' : (shapeRand < 0.85 ? 'square' : 'triangle');
                 this.color = `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100 + 155}, 255, ${Math.random() * 0.5 + 0.3})`;
             }
             update(deltaTime) {
                 this.x += this.vx * deltaTime * 0.1; this.y += this.vy * deltaTime * 0.1;
                 if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) { this.vx = -this.vx; this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); }
                 if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) { this.vy = -this.vy; this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); }

                 // Interacción repulsiva (solo si la carta es visible y no volteando)
                 if (!isFlipping) {
                     const rect = cardContainer.getBoundingClientRect(); // Usar contenedor para posición estable
                     const cardCenterX = rect.left + rect.width / 2;
                     const cardCenterY = rect.top + rect.height / 2;
                     const dx = this.x - cardCenterX; const dy = this.y - cardCenterY;
                     const distance = Math.sqrt(dx * dx + dy * dy);
                     const repelRadius = (rect.width / 2) * 1.5; // Radio de repulsión

                     if (distance < repelRadius) {
                         const force = (repelRadius - distance) / repelRadius;
                         const angle = Math.atan2(dy, dx);
                         this.vx += Math.cos(angle) * force * 0.15; // Aumentar un poco repulsión
                         this.vy += Math.sin(angle) * force * 0.15;
                     }
                 }
                 // Limitar velocidad
                 const maxSpeed = 1.5; const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                 if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; }
             }
             draw() {
                 if (!ctx) return;
                 ctx.beginPath();
                 if (this.shape === 'circle') { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); }
                 else if (this.shape === 'square') { ctx.rect(this.x - this.radius / 2, this.y - this.radius / 2, this.radius, this.radius); }
                 else { const side = this.radius * 1.7; const height = side * Math.sqrt(3) / 2; ctx.moveTo(this.x, this.y - height / 2); ctx.lineTo(this.x + side / 2, this.y + height / 2); ctx.lineTo(this.x - side / 2, this.y + height / 2); ctx.closePath(); }
                 ctx.fillStyle = this.color; ctx.fill();
             }
         }

         function createParticles() {
             if (!canvas || !ctx) return;
             particles.length = 0;
             for (let i = 0; i < numParticles; i++) {
                 let x, y, rect, dx, dy, distance;
                 const maxAttempts = 10; let attempts = 0;
                 do {
                     x = Math.random() * canvas.width; y = Math.random() * canvas.height;
                     rect = cardContainer.getBoundingClientRect();
                     dx = x - (rect.left + rect.width / 2); dy = y - (rect.top + rect.height / 2);
                     distance = Math.sqrt(dx*dx + dy*dy); attempts++;
                 } while (distance < (rect.width / 2) * 1.6 && attempts < maxAttempts) // Aumentar un poco radio inicial
                 particles.push(new Particle(x, y));
             }
         }

         let lastTime = 0;
         function animateParticles(currentTime) {
              if (!ctx) { requestAnimationFrame(animateParticles); return; } // Salir si no hay contexto
             if (lastTime === 0) lastTime = currentTime; // Inicializar tiempo
             const deltaTime = currentTime - lastTime;
             lastTime = currentTime;

             ctx.clearRect(0, 0, canvas.width, canvas.height);
             particles.forEach(particle => {
                 particle.update(deltaTime || 16.67); // Usar deltaTime o un fallback
                 particle.draw();
             });
             requestAnimationFrame(animateParticles);
         }

         function resizeCanvas() {
           if(!canvas) return;
           canvas.width = window.innerWidth;
           canvas.height = window.innerHeight;
           // Opcional: Redibujar o reposicionar partículas al cambiar tamaño?
           // Por ahora, solo ajusta el tamaño del canvas. Podrían necesitar recrearse.
           // createParticles(); // Descomentar si quieres recrearlas al redimensionar
         }

         // Inicialización
         if (canvas && ctx) {
              window.addEventListener('resize', resizeCanvas);
              resizeCanvas(); // Llamar una vez al inicio
              createParticles();
              lastTime = performance.now();
              requestAnimationFrame(animateParticles);
         } else {
             console.error("Canvas element not found or context could not be created.");
         }

    </script>

</body>
</html>
