<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carta Única Flip & Rotate (Desde Cero)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0; padding: 0; background: linear-gradient(135deg, #1a0033, #4a148c, #3f51b5); min-height: 100vh; overflow: hidden; display: flex; justify-content: center; align-items: center; position: relative; user-select: none; -webkit-user-select: none;
        }
        .card-container {
            width: 80vw; height: auto; aspect-ratio: 300 / 420; max-width: 300px; position: relative; perspective: 1000px; cursor: grab; user-select: none; -webkit-user-drag: none; z-index: 10;
        }
        .card-container:active { cursor: grabbing; }

        .card {
            width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: none; /* La transición la controla JS */ transform: rotateX(0deg) rotateY(0deg); user-select: none; -webkit-user-drag: none;
        }
        /* La clase .is-flipped ya no es necesaria en CSS, JS controla transform */

        .card-face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden; border-radius: 8px; overflow: hidden; background-color: #555; display: block; user-select: none; -webkit-user-drag: none;
        }
        .card-face img {
            width: 100%; height: 100%; object-fit: cover; display: block; pointer-events: none; user-select: none; -webkit-user-drag: none;
        }
        .card-face.front { /* No necesita z-index */ }
        .card-face.back { transform: rotateY(180deg); background-color: #333; position: relative; }

        /* Botones DENTRO de .card-face.back */
        .card-face.back .button-container { /* Contenedor opcional para botones */
             position: absolute; inset: 0; padding: 20px; display: flex; flex-direction: column; justify-content: space-between; z-index: 1;
        }
         .card-face.back .youtube-button {
             background-color: red; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; color: white; font-family: Arial, sans-serif; font-weight: bold; transition: background 0.3s; align-self: flex-start; /* Alinea arriba izquierda */
         }
         .card-face.back .youtube-button:hover { background-color: darkred; }
         .card-face.back .social-icons {
             display: flex; gap: 10px; align-self: flex-end; /* Alinea abajo derecha */
         }
         .card-face.back .social-icons a { color: white; text-decoration: none; font-size: 24px; transition: color 0.3s; }
         .card-face.back .social-icons a:hover { color: #8c9eff; }

        /* Botón de Voltear General */
        .flip-button {
            background-color: rgba(255, 255, 255, 0.8); border: none; width: 45px; height: 45px; border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background 0.3s, transform 0.3s; position: absolute; z-index: 100; bottom: 30px; right: 30px; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
         .flip-button:hover { background-color: white; transform: scale(1.1); }

        canvas#particleCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }

        @media (max-width: 600px) {
             .card-container { max-width: 90vw; }
             .flip-button { width: 40px; height: 40px; bottom: 20px; right: 20px;}
             .card-face.back .button-container { padding: 15px; }
             .card-face.back .youtube-button { padding: 6px 10px; font-size: 12px; }
             .card-face.back .social-icons { gap: 8px;}
             .card-face.back .social-icons a { font-size: 18px; }
         }
    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>

    <div class="card-container" id="cardContainer">
        <div class="card" id="interactiveCard">
            <div class="card-face front">
                <img src="carta_frente.png.jpg" alt="Frente de la Carta">
            </div>
            <div class="card-face back">
                <img src="carta_dorso.png.png" alt="Dorso de la Carta">
                <div class="button-container">
                     <button class="youtube-button" onclick="window.open('googleusercontent.com/youtube.com/4', '_blank')">
                         <i class="fab fa-youtube"></i> YouTube
                     </button>
                     <div class="social-icons">
                         <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
                         <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
                         <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <button class="flip-button" id="flipButton">
        <i class="fas fa-sync-alt" style="color: #333; font-size: 18px;"></i>
    </button>

    <script>
        // --- VARIABLES ---
        const cardContainer = document.getElementById('cardContainer');
        const cardElement = document.getElementById('interactiveCard');
        const flipButton = document.getElementById('flipButton');
        // Canvas y Partículas (si se usan)
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const particles = [];
        const numParticles = 50; // Mantener si usas partículas

        // Estado de la carta
        let isDragging = false;
        let isFlipping = false;
        let currentFlipRotation = 0; // Rotación Y debido al flip (0, 180, 360...)
        let dragRotationX = 0;       // Rotación X causada por el drag actual
        let dragRotationY = 0;       // Rotación Y causada por el drag actual

        // Variables de Drag
        let startX, startY;
        const rotationFactor = 0.4;

        // Variables de Animación de Rebote/Inercia (Opcional)
        let velocityX = 0;
        let velocityY = 0;
        const friction = 0.92;
        const springForce = 0.04;
        let animationFrameId = null;


        // --- FUNCIÓN PARA APLICAR TRANSFORMACIÓN ---
        function applyRotation() {
            // Combina la rotación del flip (Y) con la rotación del drag (X e Y)
            cardElement.style.transform = `rotateY(${currentFlipRotation + dragRotationY}deg) rotateX(${dragRotationX}deg)`;
        }

        // --- LÓGICA DE VOLTEO (FLIP) ---
        flipButton.addEventListener('click', () => {
            if (isFlipping || isDragging) return; // No hacer nada si ya está ocupada

            isFlipping = true;
            disableDrag(); // Desactivar interacción de drag
            cancelAnimationFrame(animationFrameId); // Detener rebote si lo había

            currentFlipRotation += 180; // Calcular nueva rotación de flip

            // Aplicar animación de volteo via CSS transition
            cardElement.style.transition = 'transform 0.6s ease-in-out';
            applyRotation(); // Aplicar rotación Y del flip (dragX/Y se resetean o son 0)

            // Escuchar cuando termina la transición CSS
            cardElement.addEventListener('transitionend', onFlipEnd, { once: true });
        });

        function onFlipEnd() {
            isFlipping = false;
            // Quitar transición para que el drag sea inmediato
            cardElement.style.transition = 'none';
            // Mantener currentFlipRotation actualizado (módulo 360 para evitar números grandes)
            currentFlipRotation %= 360;
            // Resetear estado de drag por si acaso
            dragRotationX = 0;
            dragRotationY = 0;
            velocityX = 0;
            velocityY = 0;
            enableDrag(); // Reactivar interacción de drag
        }

        // --- LÓGICA DE ROTACIÓN INTERACTIVA (DRAG) ---
        function handleDragStart(e) {
            if (isFlipping) return; // No empezar si está volteando
            isDragging = true;
            cardContainer.style.cursor = 'grabbing';
            cardElement.style.transition = 'none'; // Quitar transición CSS
            cancelAnimationFrame(animationFrameId); // Detener rebote

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = cardContainer.getBoundingClientRect();
            startX = clientX - (rect.left + rect.width / 2);
            startY = clientY - (rect.top + rect.height / 2);

            // Resetear drag relativo y velocidades al iniciar
            // dragRotationX = 0; // NO resetear aquí si queremos que el drag sea relativo al estado anterior
            // dragRotationY = 0;
            velocityX = 0;
            velocityY = 0;

            // Añadir listeners al documento
            document.addEventListener('mousemove', handleDragMove);
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('mouseup', handleDragEnd);
            document.addEventListener('touchend', handleDragEnd);
            document.addEventListener('mouseleave', handleDragEnd);
        }

        function handleDragMove(e) {
            if (!isDragging) return;
            if (e.touches) e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const rect = cardContainer.getBoundingClientRect();
            const currentX = clientX - (rect.left + rect.width / 2);
            const currentY = clientY - (rect.top + rect.height / 2);

            const deltaX = currentX - startX;
            const deltaY = currentY - startY;

            // Calcular la rotación causada por este drag específico
            // Esta rotación es un OFFSET sobre el estado de flip actual
            dragRotationY = deltaX * rotationFactor;
            dragRotationX = -deltaY * rotationFactor; // Vertical invierte

            // Limitar rotación del drag
            dragRotationX = Math.max(-60, Math.min(60, dragRotationX));
            dragRotationY = Math.max(-80, Math.min(80, dragRotationY));

            // Guardar velocidad para inercia
            velocityX = -deltaY * 0.5; // Velocidad X depende de mov Y
            velocityY = deltaX * 0.5;  // Velocidad Y depende de mov X

            // Aplicar transformación combinada AHORA MISMO
            applyRotation();

            // NO actualizar startX/Y para que el delta siempre sea desde el inicio del drag
        }

        function handleDragEnd() {
            if (!isDragging) return;
            isDragging = false;
            cardContainer.style.cursor = 'grab';

            // Quitar listeners del documento
            document.removeEventListener('mousemove', handleDragMove);
            document.removeEventListener('touchmove', handleDragMove);
            document.removeEventListener('mouseup', handleDragEnd);
            document.removeEventListener('touchend', handleDragEnd);
            document.removeEventListener('mouseleave', handleDragEnd);

            // Iniciar animación de rebote/inercia para volver a 0 drag offset
            if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1 || Math.abs(dragRotationX) > 0.1 || Math.abs(dragRotationY) > 0.1) {
                 animateRebound(); // La función de rebote animará dragRotationX/Y a 0
             } else {
                 // Si no hubo casi movimiento o velocidad, volver directamente a 0 drag
                 dragRotationX = 0;
                 dragRotationY = 0;
                 cardElement.style.transition = 'transform 0.4s ease-out';
                 applyRotation(); // Aplica solo el currentFlipRotation
                 setTimeout(() => { cardElement.style.transition = 'none'; }, 400);
             }
        }

         // --- Animación de Rebote/Inercia ---
         function animateRebound() {
             if (isDragging || isFlipping) { // Detener si hay interacción
                 cancelAnimationFrame(animationFrameId);
                 animationFrameId = null;
                 return;
             }

             // Aplicar inercia (velocidad actual) al OFFSET de drag
             dragRotationY += velocityY;
             dragRotationX += velocityX;

             // Aplicar fricción a la velocidad
             velocityY *= friction;
             velocityX *= friction;

             // Aplicar fuerza de resorte hacia el centro (0 de drag offset)
             const forceY = -dragRotationY * springForce;
             const forceX = -dragRotationX * springForce;
             velocityY += forceY;
             velocityX += forceX;

              // Limitar durante animación
              dragRotationX = Math.max(-90, Math.min(90, dragRotationX));
              dragRotationY = Math.max(-90, Math.min(90, dragRotationY));

              cardElement.style.transition = 'none'; // Animación manual sin CSS transition
              applyRotation(); // Aplicar estado actual (Flip + Drag offset)

             // Condición de parada
             if (Math.abs(velocityY) > 0.01 || Math.abs(velocityX) > 0.01 || Math.abs(dragRotationY) > 0.01 || Math.abs(dragRotationX) > 0.01) {
                 animationFrameId = requestAnimationFrame(animateRebound);
             } else {
                 // Asegurar estado final (sin drag offset)
                 dragRotationX = 0; dragRotationY = 0; velocityX = 0; velocityY = 0;
                 applyRotation();
                 animationFrameId = null;
             }
         }


        // --- Habilitar/Deshabilitar Drag ---
        function enableDrag() {
            cardContainer.addEventListener('mousedown', handleDragStart);
            cardContainer.addEventListener('touchstart', handleDragStart, { passive: false });
           // console.log("Drag Activado");
        }
        function disableDrag() {
            cardContainer.removeEventListener('mousedown', handleDragStart);
            cardContainer.removeEventListener('touchstart', handleDragStart);
            if(isDragging) { handleDragEnd(); } // Forzar fin si se estaba arrastrando
           // console.log("Drag Desactivado");
        }

        // Activar drag al inicio
        enableDrag();


        // --- Partículas (Código completo si se usa) ---
         class Particle { /* ... Definición ... */
             constructor(x, y) { this.x = x; this.y = y; this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.5; this.radius = Math.random() * 1.5 + 0.5; const shapeRand = Math.random(); this.shape = shapeRand < 0.7 ? 'circle' : (shapeRand < 0.85 ? 'square' : 'triangle'); this.color = `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100 + 155}, 255, ${Math.random() * 0.5 + 0.3})`; }
             update(deltaTime) { if (!deltaTime) deltaTime = 16.67; this.x += this.vx * deltaTime * 0.1; this.y += this.vy * deltaTime * 0.1; if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) { this.vx = -this.vx; this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); } if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) { this.vy = -this.vy; this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); } /* Interacción repulsiva omitida aquí por simplicidad, añadir si se necesita */ const maxSpeed = 1.5; const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy); if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; } }
             draw() { if (!ctx) return; ctx.beginPath(); if (this.shape === 'circle') { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); } else if (this.shape === 'square') { ctx.rect(this.x - this.radius / 2, this.y - this.radius / 2, this.radius, this.radius); } else { const side = this.radius * 1.7; const height = side * Math.sqrt(3) / 2; ctx.moveTo(this.x, this.y - height / 2); ctx.lineTo(this.x + side / 2, this.y + height / 2); ctx.lineTo(this.x - side / 2, this.y + height / 2); ctx.closePath(); } ctx.fillStyle = this.color; ctx.fill(); }
         }
         function createParticles() { if (!canvas || !ctx) return; particles.length = 0; for (let i = 0; i < numParticles; i++) { let x = Math.random() * canvas.width; let y = Math.random() * canvas.height; particles.push(new Particle(x, y)); } }
         let lastTime = 0; function animateParticles(currentTime) { if (!ctx) { requestAnimationFrame(animateParticles); return; } if (lastTime === 0) lastTime = currentTime; const deltaTime = currentTime - lastTime; lastTime = currentTime; ctx.clearRect(0, 0, canvas.width, canvas.height); particles.forEach(particle => { particle.update(deltaTime || 16.67); particle.draw(); }); requestAnimationFrame(animateParticles); }
         function resizeCanvas() { if(!canvas) return; canvas.width = window.innerWidth; canvas.height = window.innerHeight; /* createParticles(); // Opcional: recrear al redimensionar */ }
         if (canvas && ctx) { window.addEventListener('resize', resizeCanvas); resizeCanvas(); createParticles(); lastTime = performance.now(); requestAnimationFrame(animateParticles); } else { console.error("Canvas element not found or context could not be created."); }

    </script>

</body>
</html>
