<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cartas Interactivas v2 (Dos Cartas)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    /* CSS Original de response_pnu (o la versión relevante de dos cartas) */
    body {
      margin: 0; padding: 0; background: linear-gradient(135deg, #1a0033, #4a148c, #3f51b5); min-height: 100vh; overflow: hidden; user-select: none; display: flex; justify-content: center; align-items: center; position: relative;
    }
    .card-container { width: 80vw; height: 60vh; max-width: 300px; max-height: 420px; margin: 0 auto; position: relative; perspective: 1000px; }
    .card, .card-flip-container { width: 100%; height: 100%; background-color: transparent; border-radius: 8px; transform-style: preserve-3d; transition: opacity 0.3s ease-in-out; position: absolute; overflow: hidden; }
    .card-flip-container { opacity: 0; z-index: 1; pointer-events: none; }
    .card { opacity: 1; z-index: 2; cursor: grab; pointer-events: auto; }
    .card:active { cursor: grabbing; }
    .card img, .card-flip-face img { width: 100%; height: 100%; object-fit: cover; border-radius: 8px; position: absolute; top: 0; left: 0; transition: opacity 0.3s ease; backface-visibility: hidden; pointer-events: none; user-select: none; -webkit-user-drag: none; }
    .front-image { opacity: 1; z-index: 1; }
    .back-image { opacity: 0; z-index: 1; }
    /* Estilos botones en #rotateCard */
    #rotateCard .youtube-button, #rotateCard .social-icons { position: absolute; z-index: 0; /* Detrás imágenes */ }
    #rotateCard .youtube-button { top: 20px; left: 20px; background-color: red; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; color: white; font-family: Arial, sans-serif; font-weight: bold; transition: background 0.3s; }
     #rotateCard .youtube-button:hover { background-color: darkred; }
    #rotateCard .social-icons { bottom: 10px; right: 10px; display: flex; gap: 10px; }
    #rotateCard .social-icons a { color: white; text-decoration: none; font-size: 24px; transition: color 0.3s; }
    #rotateCard .social-icons a:hover { color: #8c9eff; }
    /* Estilos carta fantasma */
    .card-flip { width: 100%; height: 100%; background-color: transparent; border-radius: 8px; transform-style: preserve-3d; position: relative; transform: rotateY(0deg); transition: transform 0.6s ease-in-out; }
    .card-flip.torbellino { animation: torbellinoAnimation 1s ease-out 1; transition: none; }
    .card-flip-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; justify-content: center; align-items: center; border-radius: 8px; overflow: hidden; }
    .card-flip-face.back { transform: rotateY(180deg); background-color: #333; } /* Fondo oscuro cara trasera */
    /* Estilos botones en carta fantasma */
    .card-flip-face .youtube-button { background-color: red; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; position: absolute; z-index: 10; color: white; font-family: Arial, sans-serif; font-weight: bold; transition: background 0.3s, opacity 0.3s ease; opacity: 1; top: 20px; left: 20px; }
    .card-flip-face .youtube-button:hover { background-color: darkred; }
    .card-flip-face .social-icons { position: absolute; bottom: 10px; right: 10px; display: flex; gap: 10px; z-index: 10; }
    .card-flip-face .social-icons a { color: white; text-decoration: none; font-size: 24px; transition: color 0.3s; }
    .card-flip-face .social-icons a:hover { color: #8c9eff; }
    /* Botón flip general */
    .flip-button { background-color: rgba(255, 255, 255, 0.8); border: none; width: 45px; height: 45px; border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background 0.3s, transform 0.3s; position: absolute; z-index: 100; bottom: 30px; right: 30px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
    .flip-button:hover { background-color: white; transform: scale(1.1); }
    /* Canvas partículas */
    canvas#particleCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
    /* Animación torbellino */
    @keyframes torbellinoAnimation { from { transform: rotateY(0deg); } to { transform: rotateY(2160deg); } }
    /* Media Query */
    @media (max-width: 600px) { .card-container { max-width: 90vw; height: auto; aspect-ratio: 300 / 420; } .flip-button { width: 40px; height: 40px; bottom: 20px; right: 20px;} /* Ajustes botones internos */ .card-face.back .youtube-button, #rotateCard .youtube-button { padding: 6px 10px; font-size: 12px; top: 15px; left: 15px; } .card-face.back .social-icons, #rotateCard .social-icons { bottom: 8px; right: 8px; gap: 8px;} .card-face.back .social-icons a, #rotateCard .social-icons a { font-size: 18px; } }
  </style>
</head>
<body>

  <canvas id="particleCanvas"></canvas>

  <div class="card-container">

    <div class="card" id="rotateCard">
      <img class="front-image" src="carta_frente.png.jpg" alt="Frente de la Carta">
      <img class="back-image" src="carta_dorso.png.png" alt="Dorso de la Carta">
      <button class="youtube-button" id="youtubeBtnPrincipal" style="display: none;" onclick="window.open('googleusercontent.com/youtube.com/4', '_blank')">
          <i class="fab fa-youtube"></i> YouTube
      </button>
      <div class="social-icons" id="socialIconsPrincipal" style="display: none;">
          <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
          <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
          <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
      </div>
    </div>

    <div class="card-flip-container" id="flipCardContainer">
      <div class="card-flip" id="flipCard">
        <div class="card-flip-face front">
          <img src="carta_frente.png.jpg" alt="Frente de la Carta (Volteo)">
        </div>
        <div class="card-flip-face back">
          <img src="carta_dorso.png.png" alt="Dorso de la Carta (Volteo)">
          <button class="youtube-button" onclick="window.open('https://www.youtube.com/channel/UCg2fr3xBhOk34a1TocdT5jw', '_blank')">
            <i class="fab fa-youtube"></i> YouTube
          </button>
          <div class="social-icons">
            <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
            <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
            <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <button class="flip-button" id="toggleFlipBtn">
     <i class="fas fa-sync-alt" style="color: #333; font-size: 18px;"></i>
  </button>

  <script>
    // Código JS de response_pnu (Dos cartas) CON la modificación pedida
    // --- Variables ---
    const rotateCard = document.getElementById('rotateCard');
    const frontImageTop = rotateCard.querySelector('.front-image');
    const backImageTop = rotateCard.querySelector('.back-image');
    const youtubeBtnPrincipal = document.getElementById('youtubeBtnPrincipal');
    const socialIconsPrincipal = document.getElementById('socialIconsPrincipal');

    const flipCardContainer = document.getElementById('flipCardContainer');
    const flipCard = document.getElementById('flipCard');
    const toggleFlipBtn = document.getElementById('toggleFlipBtn');

    let isTouchingRotateCard = false;
    let startXRotate, startYRotate, currentXRotate, currentYRotate;
    let rotationX = 0;
    let rotationY = 0;
    let animationFrameRotateId;
    const frictionRotate = 0.92; // Ajustados para probar
    const springForceRotate = 0.04;
    const dampingRotate = 0.85; // No usado en la versión con rebote de fuerza
    const rotationFactorRotate = 0.4; // Sensibilidad
    let velocityY = 0;
    let velocityX = 0;
    let isMouseDownRotateCard = false; // Para ratón

     // --- Lógica Rotación Interactiva (con física) ---

     const handleInteractionStart = (clientX, clientY) => {
         if (rotateCard.style.opacity === '0' || isFlipping) return false;

         const rect = rotateCard.getBoundingClientRect();
         const centerX = rect.left + rect.width / 2;
         const centerY = rect.top + rect.height / 2;
         startXRotate = clientX - centerX;
         startYRotate = clientY - centerY;

         rotateCard.style.cursor = 'grabbing';
         rotateCard.style.transition = 'none';
         cancelAnimationFrame(animationFrameRotateId);
         velocityY = 0;
         velocityX = 0;
         return true; // Indica que el inicio fue válido
     };

    const handleInteractionMove = (clientX, clientY) => {
        if (!isTouchingRotateCard && !isMouseDownRotateCard) return; // Salir si no hay drag activo

        const rect = rotateCard.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        currentXRotate = clientX - centerX;
        currentYRotate = clientY - centerY;

        const deltaX = currentXRotate - startXRotate;
        const deltaY = currentYRotate - startYRotate;

        // *** APLICAR LA INVERSIÓN VERTICAL SI LA CARA TRASERA ESTÁ VISIBLE ***
        const verticalFactor = isFrontVisibleTop ? -1 : 1; // -1 si frente visible, 1 si dorso visible

        // Acumular rotación
        rotationY += deltaX * rotationFactorRotate;
        rotationX += verticalFactor * deltaY * rotationFactorRotate; // Aplicar factor de inversión

        // Limitar rotación
        rotationX = Math.max(-60, Math.min(60, rotationX));
        rotationY = Math.max(-80, Math.min(80, rotationY));

        // Guardar velocidad para inercia
        // La velocidad SÍ debe ser consistente, no invertida por la cara visible
        velocityX = (-deltaY) * 0.5; // Siempre -deltaY para velocidad X
        velocityY = deltaX * 0.5;   // Siempre deltaX para velocidad Y

        // Aplicar transformación (solo rotación de drag, el flip state no afecta esta carta)
        rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

        // Actualizar punto de inicio para el siguiente movimiento
        startXRotate = currentXRotate;
        startYRotate = currentYRotate;
    };


     const handleInteractionEnd = () => {
        if (!isTouchingRotateCard && !isMouseDownRotateCard) return; // Salir si no hubo drag

        isTouchingRotateCard = false;
        isMouseDownRotateCard = false;
        rotateCard.style.cursor = 'grab';

         // Quitar listeners de documento para ratón
        document.removeEventListener('mousemove', handleMouseMoveRotate);
        document.removeEventListener('mouseup', handleMouseUpRotate);
        document.removeEventListener('mouseleave', handleMouseUpRotate); // Añadido mouseleave

         // Iniciar animación de rebote/inercia si hay velocidad o desviación
        if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1 || Math.abs(rotationX) > 0.1 || Math.abs(rotationY) > 0.1) {
            animateReboundRotate();
        } else {
            // Si no, volver al centro suavemente
            smoothReturnToCenter();
        }
     };

     // Listener táctil
    rotateCard.addEventListener('touchstart', (e) => {
        if (handleInteractionStart(e.touches[0].clientX, e.touches[0].clientY)) {
            isTouchingRotateCard = true;
             e.preventDefault(); // Prevenir scroll solo si el drag inicia
        }
    }, { passive: false });

    rotateCard.addEventListener('touchmove', (e) => {
        if (!isTouchingRotateCard) return;
        handleInteractionMove(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault(); // Prevenir scroll durante drag
    }, { passive: false });

    rotateCard.addEventListener('touchend', handleInteractionEnd);
    rotateCard.addEventListener('touchcancel', handleInteractionEnd); // Tratar cancel como end

     // Listener ratón
     rotateCard.addEventListener('mousedown', (e) => {
        if (handleInteractionStart(e.clientX, e.clientY)) {
            isMouseDownRotateCard = true;
             // Añadir listeners al documento
            document.addEventListener('mousemove', handleMouseMoveRotate);
            document.addEventListener('mouseup', handleMouseUpRotate);
            document.addEventListener('mouseleave', handleMouseUpRotate); // Importante
        }
     });

     // Funciones wrapper para listeners de documento (necesarias para removeEventListener)
     const handleMouseMoveRotate = (e) => handleInteractionMove(e.clientX, e.clientY);
     const handleMouseUpRotate = () => handleInteractionEnd();


     // Animación de rebote/inercia (igual que en el código anterior)
     const animateReboundRotate = () => {
         if (isTouchingRotateCard || isMouseDownRotateCard || isFlipping) {
             cancelAnimationFrame(animationFrameRotateId);
             animationFrameRotateId = null;
             return;
         } // No animar si se está tocando/volteando

         // Aplicar inercia
         rotationY += velocityY;
         rotationX += velocityX;

         // Aplicar fricción a la velocidad
         velocityY *= frictionRotate;
         velocityX *= frictionRotate;

         // Aplicar fuerza de resorte hacia el centro (0,0 de rotación por drag)
         const forceY = -rotationY * springForceRotate;
         const forceX = -rotationX * springForceRotate;
         velocityY += forceY;
         velocityX += forceX;

          // Limitar
          rotationX = Math.max(-90, Math.min(90, rotationX));
          rotationY = Math.max(-90, Math.min(90, rotationY));

         rotateCard.style.transition = 'none'; // Asegurar no transición CSS
         rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

         // Condición de parada
         if (Math.abs(velocityY) > 0.01 || Math.abs(velocityX) > 0.01 || Math.abs(rotationY) > 0.01 || Math.abs(rotationX) > 0.01) {
             animationFrameRotateId = requestAnimationFrame(animateReboundRotate);
         } else {
             smoothReturnToCenter(true); // Asegurar centro al final
             animationFrameId = null;
         }
     };

     // Función para volver suavemente a 0,0 (igual que antes)
      const smoothReturnToCenter = (forceFinish = false) => {
          if (isTouchingRotateCard || isMouseDownRotateCard || isFlipping) return;
          cancelAnimationFrame(animationFrameRotateId); // Detener rebote si se llama explícitamente

          const targetX = 0;
          const targetY = 0;
          const dX = targetX - rotationX;
          const dY = targetY - rotationY;
          const distance = Math.sqrt(dX*dX + dY*dY);

          if (!forceFinish && distance < 0.1) { // Ya está cerca
              rotationX = 0; rotationY = 0;
              rotateCard.style.transition = 'none';
              rotateCard.style.transform = `rotateX(0deg) rotateY(0deg)`;
              return;
          }

          // Aplicar fuerza y damping directamente a la posición para suavizado
          rotationX += dX * 0.15; // Velocidad de retorno (ajustar)
          rotationY += dY * 0.15;
         // rotationX *= 0.85; // Damping (ajustar)
         // rotationY *= 0.85;

          rotateCard.style.transition = 'none';
          rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

          // Condición de parada
          if (!forceFinish && distance > 0.1) {
               animationFrameRotateId = requestAnimationFrame(() => smoothReturnToCenter());
          } else {
               rotationX = 0; rotationY = 0;
               rotateCard.style.transform = `rotateX(0deg) rotateY(0deg)`;
               animationFrameId = null;
          }
      };


    // --- Lógica del Flip (Igual que en response_pnu, con controles de botones añadidos) ---
    let currentRotationFlip = 0;
    let flipCount = 0;
    let isFlipping = false; // Ya definida globalmente
    const torbellinoDuration = 1000;
    let isFrontVisibleTop = true; // Rastrea qué cara se muestra en #rotateCard

    toggleFlipBtn.addEventListener('click', () => {
      if (isFlipping || isTouchingRotateCard || isMouseDownRotateCard) return;
      isFlipping = true;
      cancelAnimationFrame(animationFrameRotateId); // Detener rebote

      // Asegurarse que la carta principal esté centrada antes de ocultarla
       smoothReturnToCenter(true); // Forzar centro inmediato
       rotateCard.style.transition = 'none'; // Asegurar no transición

      // Ocultar carta principal, mostrar contenedor de flip
      rotateCard.style.opacity = 0;
      rotateCard.style.pointerEvents = 'none';
      flipCardContainer.style.opacity = 1;
      flipCardContainer.style.pointerEvents = 'auto';

      // Actualizar estado visual de la carta principal (imágenes y botones)
      if (isFrontVisibleTop) {
          frontImageTop.style.opacity = 0;
          backImageTop.style.opacity = 1;
          if(youtubeBtnPrincipal) youtubeBtnPrincipal.style.display = 'block';
          if(socialIconsPrincipal) socialIconsPrincipal.style.display = 'flex';
      } else {
          frontImageTop.style.opacity = 1;
          backImageTop.style.opacity = 0;
          if(youtubeBtnPrincipal) youtubeBtnPrincipal.style.display = 'none';
          if(socialIconsPrincipal) socialIconsPrincipal.style.display = 'none';
      }
      // Invertir estado para la próxima vez que se muestre #rotateCard
      isFrontVisibleTop = !isFrontVisibleTop;

      flipCount++;
      let flipDuration = 600;

      // Aplicar rotación a la carta fantasma
      // Sincronizar su estado inicial con el de la carta principal
      flipCard.style.transition = 'none'; // Sin transición para estado inicial
      flipCard.style.transform = `rotateY(${isFrontVisibleTop ? 180 : 0}deg)`; // Ponerla como quedó la principal

      // Forzar reflow para aplicar transición después
      void flipCard.offsetWidth;

      // Ejecutar animación
      if (flipCount % 10 === 0) { // Torbellino
        flipCard.style.transition = 'none'; // Quitar transición CSS
        flipCard.classList.add('torbellino');
        flipDuration = torbellinoDuration;
        setTimeout(() => {
          flipCard.classList.remove('torbellino');
          // Asegurar que termina en el estado correcto (ya volteada respecto al inicio)
          currentRotationFlip = isFrontVisibleTop ? 180 : 0; // Estado final del flip
          flipCard.style.transform = `rotateY(${currentRotationFlip}deg)`;
        }, torbellinoDuration);
      } else { // Flip normal
        flipCard.style.transition = 'transform 0.6s ease-in-out';
        currentRotationFlip = isFrontVisibleTop ? 180 : 0; // Estado final del flip
        flipCard.style.transform = `rotateY(${currentRotationFlip}deg)`;
      }

      // Programar la reversión de visibilidad
      setTimeout(() => {
          rotateCard.style.opacity = 1;
          rotateCard.style.pointerEvents = 'auto';
          flipCardContainer.style.opacity = 0;
          flipCardContainer.style.pointerEvents = 'none';
          isFlipping = false;
           // Resetear rotación de drag de la carta principal al volver a mostrarla
           rotationX = 0;
           rotationY = 0;
           rotateCard.style.transform = `rotateX(0deg) rotateY(0deg)`;

      }, flipDuration + 50); // Margen post-animación
    });


    // --- Lógica de Partículas (Igual que en response_iik) ---
    class Particle {
         constructor(x, y) { /* ... */ }
         update(deltaTime) { /* ... con repulsión ... */ }
         draw() { /* ... */ }
     }
     function createParticles() { /* ... */ }
     let lastTime = 0;
     function animateParticles(currentTime) { /* ... */ }
     function resizeCanvas() { /* ... */ }

     // Inicialización Partículas (copiar completo si se usa)
     if (canvas && ctx) {
         window.addEventListener('resize', resizeCanvas);
         resizeCanvas();
         createParticles();
         lastTime = performance.now();
         requestAnimationFrame(animateParticles);
     } else { console.error("Canvas no encontrado"); }

     // Definiciones completas de Particle y funciones auxiliares de partículas
     // (Basadas en el código de response_iik para completitud)
     class Particle {
         constructor(x, y) {
             this.x = x; this.y = y;
             this.vx = (Math.random() - 0.5) * 0.5; this.vy = (Math.random() - 0.5) * 0.5;
             this.radius = Math.random() * 1.5 + 0.5;
             const shapeRand = Math.random();
             this.shape = shapeRand < 0.7 ? 'circle' : (shapeRand < 0.85 ? 'square' : 'triangle');
             this.color = `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100 + 155}, 255, ${Math.random() * 0.5 + 0.3})`;
         }
         update(deltaTime) {
              if (!deltaTime) deltaTime = 16.67; // Fallback si deltaTime es 0 o undefined
             this.x += this.vx * deltaTime * 0.1; this.y += this.vy * deltaTime * 0.1;
             if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) { this.vx = -this.vx; this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); }
             if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) { this.vy = -this.vy; this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); }

             // Interacción repulsiva con #rotateCard (solo si es visible)
             if (rotateCard.style.opacity !== '0' && !isFlipping) {
                 const rect = rotateCard.getBoundingClientRect(); // Usar rotateCard para posición
                 if (rect.width > 0) { // Asegurar que la carta tiene dimensiones
                     const cardCenterX = rect.left + rect.width / 2;
                     const cardCenterY = rect.top + rect.height / 2;
                     const dx = this.x - cardCenterX; const dy = this.y - cardCenterY;
                     const distance = Math.sqrt(dx * dx + dy * dy);
                     const repelRadius = (rect.width / 2) * 1.5;

                     if (distance < repelRadius && distance > 0) { // Evitar división por cero si distance=0
                         const force = (repelRadius - distance) / repelRadius;
                         const angle = Math.atan2(dy, dx);
                         this.vx += Math.cos(angle) * force * 0.15;
                         this.vy += Math.sin(angle) * force * 0.15;
                     }
                 }
             }
             // Limitar velocidad
             const maxSpeed = 1.5; const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
             if (speed > maxSpeed) { this.vx = (this.vx / speed) * maxSpeed; this.vy = (this.vy / speed) * maxSpeed; }
         }
         draw() {
             if (!ctx) return;
             ctx.beginPath();
             if (this.shape === 'circle') { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); }
             else if (this.shape === 'square') { ctx.rect(this.x - this.radius / 2, this.y - this.radius / 2, this.radius, this.radius); }
             else { const side = this.radius * 1.7; const height = side * Math.sqrt(3) / 2; ctx.moveTo(this.x, this.y - height / 2); ctx.lineTo(this.x + side / 2, this.y + height / 2); ctx.lineTo(this.x - side / 2, this.y + height / 2); ctx.closePath(); }
             ctx.fillStyle = this.color; ctx.fill();
         }
     }

     function createParticles() {
         if (!canvas || !ctx) return;
         particles.length = 0;
         const rect = rotateCard.getBoundingClientRect(); // Obtener dimensiones una vez
         const cardRadiusSq = ((rect.width / 2) * 1.6) ** 2; // Usar radio al cuadrado y un poco más grande

         for (let i = 0; i < numParticles; i++) {
             let x, y, dx, dy, distanceSq;
             const maxAttempts = 10; let attempts = 0;
             do {
                 x = Math.random() * canvas.width; y = Math.random() * canvas.height;
                 if (rect.width > 0) {
                     dx = x - (rect.left + rect.width / 2); dy = y - (rect.top + rect.height / 2);
                     distanceSq = dx*dx + dy*dy;
                 } else {
                     distanceSq = Infinity; // Si la carta no tiene tamaño, colocar en cualquier lugar
                 }
                 attempts++;
             } while (distanceSq < cardRadiusSq && attempts < maxAttempts)
             particles.push(new Particle(x, y));
         }
     }

     // let lastTime = 0; // Ya definido arriba
     function animateParticles(currentTime) {
          if (!ctx) { requestAnimationFrame(animateParticles); return; }
          if (lastTime === 0) lastTime = currentTime;
          const deltaTime = currentTime - lastTime;
          lastTime = currentTime;

          ctx.clearRect(0, 0, canvas.width, canvas.height);
          particles.forEach(particle => {
              particle.update(deltaTime || 16.67);
              particle.draw();
          });
          requestAnimationFrame(animateParticles);
     }

     function resizeCanvas() {
       if(!canvas) return;
       canvas.width = window.innerWidth;
       canvas.height = window.innerHeight;
       // Podríamos llamar a createParticles() aquí si queremos que se adapten al nuevo tamaño
       // createParticles();
     }
  </script>

</body>
</html>
