<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cartas Interactivas con Partículas</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1a0033, #4a148c, #3f51b5);
      min-height: 100vh;
      overflow: hidden;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    .card-container {
      width: 80vw;
      height: 60vh;
      max-width: 300px;
      max-height: 420px;
      margin: 0 auto;
      position: relative;
      perspective: 1000px;
    }

    .card, .card-flip-container {
      width: 100%;
      height: 100%;
      background-color: transparent;
      border-radius: 8px;
      transform-style: preserve-3d;
      transition: opacity 0.3s ease-in-out;
      position: absolute;
      overflow: hidden;
    }

    .card-flip-container {
      opacity: 0;
      z-index: 1;
      /* Añadido para asegurar que no capture eventos cuando está oculto */
      pointer-events: none;
    }

    .card {
      opacity: 1;
      z-index: 2;
      cursor: grab;
       /* Añadido para asegurar que capture eventos cuando está visible */
      pointer-events: auto;
    }

    .card img, .card-flip-face img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
      position: absolute;
      top: 0;
      left: 0;
      transition: opacity 0.3s ease;
      /* Importante para evitar que se vean los botones de atrás */
      backface-visibility: hidden;
    }

    .front-image {
      opacity: 1;
      z-index: 1; /* Imagen frontal por encima de botones */
    }

    .back-image {
      opacity: 0;
      z-index: 1; /* Imagen trasera por encima de botones */
    }

     /* Estilos para los botones dentro de #rotateCard */
    #rotateCard .youtube-button,
    #rotateCard .social-icons {
        position: absolute;
        z-index: 0; /* Detrás de las imágenes */
        /* 'display: none' se controla por JS */
    }
     #rotateCard .youtube-button {
        top: 20px;
        left: 20px;
     }
    #rotateCard .social-icons {
       bottom: 10px;
       right: 10px;
       /* Asegurarse que display flex funcione bien cuando se muestre */
       /* display: flex; ya está en la clase .social-icons */
       gap: 10px;
    }

    .card-flip {
      width: 100%;
      height: 100%;
      background-color: transparent;
      border-radius: 8px;
      transform-style: preserve-3d;
      position: relative;
      transform: rotateY(0deg);
      transition: transform 0.6s ease-in-out;
    }

    .card-flip.torbellino {
      animation: torbellinoAnimation 1s ease-out 1;
      transition: none;
    }

    .card-flip-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      border-radius: 8px; /* Añadido para que las caras tengan bordes redondeados */
      overflow: hidden; /* Añadido por si acaso */
    }

    .card-flip-face.back {
      transform: rotateY(180deg);
    }

    /* Botón de voltear general */
    .flip-button {
      background-color: rgba(0, 0, 0, 0.7);
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: background 0.3s;
      position: absolute; /* Lo ponemos relativo al body */
      z-index: 10;
      top: 20px;
      right: 20px; /* Ajusta si prefieres otra posición general */
    }
     /* Estilos específicos para botones Y DENTRO DE LA CARTA QUE VOLTEA */
     .card-flip-face .youtube-button {
        background-color: red;
        border: none;
        padding: 8px 12px;
        border-radius: 5px;
        cursor: pointer;
        position: absolute; /* Posición absoluta RELATIVA a la cara */
        z-index: 10; /* Encima de la imagen de la cara */
        color: white;
        font-family: Arial, sans-serif;
        font-weight: bold;
        transition: background 0.3s, opacity 0.3s ease;
        opacity: 1;
        top: 20px;
        left: 20px;
     }
    .card-flip-face .youtube-button:hover {
      background-color: darkred;
    }

     .card-flip-face .social-icons {
       position: absolute; /* Posición absoluta RELATIVA a la cara */
       bottom: 10px;
       right: 10px;
       display: flex;
       gap: 10px;
       z-index: 10; /* Encima de la imagen de la cara */
     }

     .card-flip-face .social-icons a {
       color: white;
       text-decoration: none;
       font-size: 24px;
       transition: color 0.3s;
     }

     .card-flip-face .social-icons a:hover {
       color: #3f51b5; /* O el color que prefieras */
     }


    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0; /* Detrás de las cartas */
    }

    /* Redes sociales generales (si las quieres fuera de la carta) - Borré las anteriores que estaban fuera */


    @keyframes torbellinoAnimation {
      from { transform: rotateY(0deg); }
      to { transform: rotateY(2160deg); } /* 6 vueltas */
    }

    @media (max-width: 600px) {
      .card-container {
        width: 90vw;
        height: auto; /* Ajustar altura automáticamente */
        aspect-ratio: 300 / 420; /* Mantener proporción */
        max-width: 90vw; /* Limitar ancho */
        max-height: none;
      }

      .flip-button {
        padding: 6px;
        top: 15px;
        right: 15px;
        width: 36px;
        height: 36px;
      }
       /* Ajustar botones dentro de las caras para móvil */
       .card-flip-face .youtube-button {
           padding: 6px 10px;
           font-size: 12px; /* Reducir tamaño fuente */
           top: 15px;
           left: 15px;
       }
       .card-flip-face .social-icons {
           bottom: 8px;
           right: 8px;
           gap: 8px;
       }
       .card-flip-face .social-icons a {
           font-size: 18px;
       }
        /* Ajustar botones dentro de #rotateCard para móvil (si son diferentes) */
        #rotateCard .youtube-button {
            /* Ajustes específicos si son necesarios */
             padding: 6px 10px;
             font-size: 12px;
             top: 15px;
             left: 15px;
        }
        #rotateCard .social-icons {
             bottom: 8px;
             right: 8px;
             gap: 8px;
        }
         #rotateCard .social-icons a {
             font-size: 18px;
        }
    }
  </style>
</head>
<body>

  <canvas id="particleCanvas"></canvas>

  <div class="card-container">

    <div class="card" id="rotateCard">
      <img class="front-image" src="carta_frente.png.jpg" alt="Frente de la Carta">
      <img class="back-image" src="carta_dorso.png.png" alt="Dorso de la Carta">

      <button class="youtube-button" id="youtubeBtnPrincipal" style="display: none;" onclick="window.open('googleusercontent.com/youtube.com/4', '_blank')">
          <i class="fab fa-youtube"></i> YouTube </button>
      <div class="social-icons" id="socialIconsPrincipal" style="display: none;">
          <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
          <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
          <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
      </div>
      </div>

    <div class="card-flip-container" id="flipCardContainer">
      <div class="card-flip" id="flipCard">
        <div class="card-flip-face front">
          <img src="carta_frente.png.jpg" alt="Frente de la Carta (Volteo)">
           </div>
        <div class="card-flip-face back">
          <img src="carta_dorso.png.png" alt="Dorso de la Carta (Volteo)">
          <button class="youtube-button" onclick="window.open('https://www.youtube.com/channel/UCg2fr3xBhOk34a1TocdT5jw', '_blank')">
            <i class="fab fa-youtube"></i> YouTube </button>
          <div class="social-icons">
            <a href="https://facebook.com/tu_perfil" target="_blank"><i class="fab fa-facebook-f"></i></a>
            <a href="https://twitter.com/tu_perfil" target="_blank"><i class="fab fa-twitter"></i></a>
            <a href="https://instagram.com/tu_perfil" target="_blank"><i class="fab fa-instagram"></i></a>
          </div>
        </div>
      </div>
    </div>

  </div>

  <button class="flip-button" id="toggleFlipBtn">
     <i class="fas fa-sync-alt" style="color: white; font-size: 18px;"></i>
  </button>

  <script>
    const rotateCard = document.getElementById('rotateCard');
    const frontImageTop = rotateCard.querySelector('.front-image');
    const backImageTop = rotateCard.querySelector('.back-image');
    // IDs para los botones de la carta principal
    const youtubeBtnPrincipal = document.getElementById('youtubeBtnPrincipal');
    const socialIconsPrincipal = document.getElementById('socialIconsPrincipal');


    const flipCardContainer = document.getElementById('flipCardContainer');
    const flipCard = document.getElementById('flipCard');

    const toggleFlipBtn = document.getElementById('toggleFlipBtn');

    let isTouchingRotateCard = false;
    let startXRotate, startYRotate, currentXRotate, currentYRotate;
    let rotationX = 0;
    let rotationY = 0;
    let animationFrameRotateId;
    const frictionRotate = 0.9;
    // Ajustados para una sensación quizás menos 'gomosa'
    const springForceRotate = 0.002; // Más bajo = menos resistencia
    const dampingRotate = 0.85; // Más alto = menos rebote
    const rotationFactorRotate = 0.3; // Sensibilidad
    let velocityY = 0;
    let velocityX = 0;

    const handleTouchStartRotate = (e) => {
        // Solo rotar si la carta principal es visible
        if (rotateCard.style.opacity === '0' || isFlipping) return;

        isTouchingRotateCard = true;
        const rect = rotateCard.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        startXRotate = clientX - centerX;
        startYRotate = clientY - centerY;

        rotateCard.style.cursor = 'grabbing';
        rotateCard.style.transition = 'none'; // Sin transición durante el arrastre
        cancelAnimationFrame(animationFrameRotateId);
        velocityY = 0;
        velocityX = 0;
        // No prevenir default si queremos que funcione en desktop también con drag
        // e.preventDefault(); // Quitado para posible compatibilidad desktop
    };


    const handleTouchMoveRotate = (e) => {
      if (!isTouchingRotateCard) return;
      const rect = rotateCard.getBoundingClientRect();
       const clientX = e.touches ? e.touches[0].clientX : e.clientX;
       const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      currentXRotate = clientX - centerX;
      currentYRotate = clientY - centerY;
      const deltaX = currentXRotate - startXRotate;
      const deltaY = currentYRotate - startYRotate;

      rotationY += deltaX * rotationFactorRotate;
      rotationX -= deltaY * rotationFactorRotate;

      // Limitar un poco la rotación máxima para evitar giros extremos
       rotationX = Math.max(-60, Math.min(60, rotationX));
       rotationY = Math.max(-60, Math.min(60, rotationY));


      // Aplicar la rotación
      rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

       // Actualizar velocidades para la inercia (quizás solo al final?)
       // Mejor calcular velocidad instantánea aquí para inercia
       velocityY = deltaX * 0.5; // Ajustar sensibilidad inercia
       velocityX = -deltaY * 0.5;

      startXRotate = currentXRotate;
      startYRotate = currentYRotate;
       // No prevenir default aquí tampoco
       // e.preventDefault(); // Quitado
    };


    const handleTouchEndRotate = () => {
      if (!isTouchingRotateCard) return; // Añadido chequeo por si acaso
      isTouchingRotateCard = false;
      rotateCard.style.cursor = 'grab';
      // Quitamos la transición ease-out para que la animación de rebote sea fluida
      // rotateCard.style.transition = 'transform 0.3s ease-out';

      // Iniciar animación de rebote/inercia si hay velocidad
      if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
          animateReboundRotate();
      } else {
          // Si no hay velocidad, iniciar un rebote suave al centro
          smoothReturnToCenter();
      }
    };

     // Animación de inercia y rebote
     const animateReboundRotate = () => {
         if (isTouchingRotateCard) return; // No animar si se está tocando

         // Aplicar inercia
         rotationY += velocityY;
         rotationX += velocityX;

         // Aplicar fricción a la velocidad
         velocityY *= frictionRotate;
         velocityX *= frictionRotate;

         // Aplicar fuerza de resorte hacia el centro (0,0)
         const forceY = -rotationY * springForceRotate;
         const forceX = -rotationX * springForceRotate;

         // Aplicar fuerza a la velocidad (aceleración)
         velocityY += forceY;
         velocityX += forceX;

          // Limitar rotación por si acaso
         rotationX = Math.max(-90, Math.min(90, rotationX));
         rotationY = Math.max(-90, Math.min(90, rotationY));


         rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

         // Condición de parada: si la velocidad y la desviación son mínimas
         if (Math.abs(velocityY) > 0.01 || Math.abs(velocityX) > 0.01 || Math.abs(rotationY) > 0.1 || Math.abs(rotationX) > 0.1) {
             animationFrameRotateId = requestAnimationFrame(animateReboundRotate);
         } else {
             // Asegurarse que quede exactamente en 0 al final
             smoothReturnToCenter(true); // Forzar el final
         }
     };

    // Función para volver suavemente a 0,0 si no hay inercia o al final del rebote
     const smoothReturnToCenter = (forceFinish = false) => {
         if (isTouchingRotateCard) return;

          // Aplicar fuerza de resorte hacia el centro (0,0)
         const forceY = -rotationY * (springForceRotate * 5); // Más fuerza para volver rápido
         const forceX = -rotationX * (springForceRotate * 5);

          // Aplicar fricción/damping a la posición directamente
         rotationY += forceY;
         rotationX += forceX;
         rotationY *= dampingRotate; // Damping aplicado a la posición
         rotationX *= dampingRotate;

         rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;

         // Condición de parada
         if (!forceFinish && (Math.abs(rotationY) > 0.05 || Math.abs(rotationX) > 0.05)) {
              animationFrameRotateId = requestAnimationFrame(() => smoothReturnToCenter());
         } else {
              // Asegurar el final
              rotationX = 0;
              rotationY = 0;
              rotateCard.style.transform = `rotateX(0deg) rotateY(0deg)`;
         }
     };


    const handleTouchCancelRotate = () => {
        // Comportamiento similar a touchend si se cancela
      if (!isTouchingRotateCard) return;
      isTouchingRotateCard = false;
      rotateCard.style.cursor = 'grab';
      smoothReturnToCenter(); // Volver al centro al cancelar
    };

    // --- Añadir Eventos de Ratón para Desktop ---
     let isMouseDownRotateCard = false;

    const handleMouseDownRotate = (e) => {
        if (rotateCard.style.opacity === '0' || isFlipping) return;

        isMouseDownRotateCard = true;
        const rect = rotateCard.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        startXRotate = e.clientX - centerX;
        startYRotate = e.clientY - centerY;

        rotateCard.style.cursor = 'grabbing';
        rotateCard.style.transition = 'none';
        cancelAnimationFrame(animationFrameRotateId);
        velocityY = 0;
        velocityX = 0;
        // Añadir listeners de mousemove y mouseup al DOCUMENTO
        document.addEventListener('mousemove', handleMouseMoveRotate);
        document.addEventListener('mouseup', handleMouseUpRotate);
    };

    const handleMouseMoveRotate = (e) => {
        if (!isMouseDownRotateCard) return;
        // Simular handleTouchMoveRotate usando e.clientX/Y
        const rect = rotateCard.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        currentXRotate = e.clientX - centerX;
        currentYRotate = e.clientY - centerY;
        const deltaX = currentXRotate - startXRotate;
        const deltaY = currentYRotate - startYRotate;

        rotationY += deltaX * rotationFactorRotate;
        rotationX -= deltaY * rotationFactorRotate;
        rotationX = Math.max(-60, Math.min(60, rotationX));
        rotationY = Math.max(-60, Math.min(60, rotationY));
        rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
        velocityX = -deltaY * 0.5; // Guardar última velocidad
        velocityY = deltaX * 0.5;
        startXRotate = currentXRotate;
        startYRotate = currentYRotate;
    };

    const handleMouseUpRotate = () => {
        if (!isMouseDownRotateCard) return;
        isMouseDownRotateCard = false;
        rotateCard.style.cursor = 'grab';
        // Quitar listeners del documento
        document.removeEventListener('mousemove', handleMouseMoveRotate);
        document.removeEventListener('mouseup', handleMouseUpRotate);
        // Iniciar animación de rebote/inercia (similar a touchend)
        if (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1) {
             animateReboundRotate();
         } else {
             smoothReturnToCenter();
         }
    };

    // Asignar eventos
    rotateCard.addEventListener('touchstart', handleTouchStartRotate, { passive: false });
    rotateCard.addEventListener('touchmove', handleTouchMoveRotate, { passive: false });
    rotateCard.addEventListener('touchend', handleTouchEndRotate);
    rotateCard.addEventListener('touchcancel', handleTouchCancelRotate);
    // Añadir eventos de ratón
    rotateCard.addEventListener('mousedown', handleMouseDownRotate);
     // Nota: mouseleave en la propia carta podría ser problemático si el ratón sale rápido
     // Es mejor manejar mouseup en el documento como se hizo arriba.


    // --- Lógica del Flip ---
    let currentRotationFlip = 0; // Renombrado para evitar conflicto
    let flipCount = 0;
    let isFlipping = false;
    const torbellinoDuration = 1000; // ms
    let isFrontVisibleTop = true; // Rastrea qué cara se muestra en #rotateCard

    toggleFlipBtn.addEventListener('click', () => {
      if (isFlipping || isTouchingRotateCard || isMouseDownRotateCard) return; // No voltear si ya está volteando o si se está rotando
      isFlipping = true;

        // Asegurarse que la carta principal esté centrada antes de ocultarla
        rotationX = 0;
        rotationY = 0;
        rotateCard.style.transition = 'transform 0.1s ease-out'; // Transición suave al centro
        rotateCard.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;


      // Ocultar carta principal, mostrar contenedor de flip
       setTimeout(() => { // Dar tiempo a que vuelva al centro
            rotateCard.style.opacity = 0;
            rotateCard.style.pointerEvents = 'none'; // Desactivar eventos
            flipCardContainer.style.opacity = 1;
            flipCardContainer.style.pointerEvents = 'auto'; // Activar eventos


            // Actualizar la opacidad de las imágenes DENTRO de #rotateCard
            // para que cuando vuelva a aparecer, muestre la cara correcta.
            if (isFrontVisibleTop) {
                frontImageTop.style.opacity = 0;
                backImageTop.style.opacity = 1;
                 // --- NUEVO: Mostrar/Ocultar botones de #rotateCard ---
                 if(youtubeBtnPrincipal) youtubeBtnPrincipal.style.display = 'block';
                 if(socialIconsPrincipal) socialIconsPrincipal.style.display = 'flex';
            } else {
                frontImageTop.style.opacity = 1;
                backImageTop.style.opacity = 0;
                 // --- NUEVO: Mostrar/Ocultar botones de #rotateCard ---
                 if(youtubeBtnPrincipal) youtubeBtnPrincipal.style.display = 'none';
                 if(socialIconsPrincipal) socialIconsPrincipal.style.display = 'none';
            }
            isFrontVisibleTop = !isFrontVisibleTop; // Invertir para la próxima vez

            flipCount++;

            // Determinar animación y duración
            let flipDuration = 600; // ms
            if (flipCount % 10 === 0) { // Torbellino cada 10 flips
              flipCard.style.transition = 'none'; // Quitar transición para animación
              flipCard.classList.add('torbellino');
              flipDuration = torbellinoDuration;

              // Quitar clase y resetear después de la animación
              setTimeout(() => {
                flipCard.classList.remove('torbellino');
                currentRotationFlip = isFrontVisibleTop ? 0 : 180; // Asegurar estado correcto
                flipCard.style.transform = `rotateY(${currentRotationFlip}deg)`;
                 // Volver a poner transición normal si se desea para futuros flips normales
                 setTimeout(() => flipCard.style.transition = 'transform 0.6s ease-in-out', 50);

              }, torbellinoDuration);

            } else {
              // Flip normal de 180 grados
               flipCard.style.transition = 'transform 0.6s ease-in-out'; // Asegurar transición normal
              currentRotationFlip += 180; // Acumular rotación
              flipCard.style.transform = `rotateY(${currentRotationFlip}deg)`;
            }

            // Programar la reversión de visibilidad después de la animación
            setTimeout(() => {
                rotateCard.style.opacity = 1;
                rotateCard.style.pointerEvents = 'auto'; // Reactivar eventos
                flipCardContainer.style.opacity = 0;
                flipCardContainer.style.pointerEvents = 'none'; // Desactivar eventos
                isFlipping = false;
            }, flipDuration + 50); // Añadir un pequeño margen

       }, 100); // Espera 100ms para que la carta principal vuelva al centro
    });


    // --- Lógica de Partículas ---
    const canvas = document.getElementById('particleCanvas');
    const ctx = canvas.getContext('2d');
    const particles = [];
     const numParticles = 50; // Número de partículas

    class Particle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 0.5; // Velocidad inicial más lenta
            this.vy = (Math.random() - 0.5) * 0.5;
            this.radius = Math.random() * 1.5 + 0.5; // Más pequeñas
            // Hacer más círculos que otras formas
            const shapeRand = Math.random();
            this.shape = shapeRand < 0.7 ? 'circle' : (shapeRand < 0.85 ? 'square' : 'triangle');
             // Color similar al gradiente de fondo o blanco/cyan
            this.color = `rgba(${Math.random() * 100 + 100}, ${Math.random() * 100 + 155}, 255, ${Math.random() * 0.5 + 0.3})`;
        }

      update(deltaTime) { // Pasar deltaTime para movimiento consistente
          // Movimiento normal
          this.x += this.vx * deltaTime * 0.1; // Ajustar multiplicador para velocidad general
          this.y += this.vy * deltaTime * 0.1;

          // Rebotar en los bordes del canvas
          if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
            this.vx = -this.vx;
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); // Prevenir que se salga
          }
          if (this.y - this.radius < 0 || this.y + this.radius > canvas.height) {
            this.vy = -this.vy;
             this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); // Prevenir que se salga
          }

          // Interacción repulsiva con la carta principal (si no está volteando)
          if (rotateCard.style.opacity !== '0' && !isFlipping) {
              const rect = rotateCard.getBoundingClientRect();
              const cardCenterX = rect.left + rect.width / 2;
              const cardCenterY = rect.top + rect.height / 2;
              const dx = this.x - cardCenterX;
              const dy = this.y - cardCenterY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const repelRadius = (rect.width / 2) * 1.4; // Un radio un poco mayor que la carta

              if (distance < repelRadius) {
                  const force = (repelRadius - distance) / repelRadius; // Fuerza mayor cerca del borde
                  const angle = Math.atan2(dy, dx);
                  // Añadir una fuerza que las empuje hacia afuera
                  this.vx += Math.cos(angle) * force * 0.1; // Ajustar fuerza de repulsión
                  this.vy += Math.sin(angle) * force * 0.1;
              }
          }

            // Limitar velocidad máxima para evitar que se disparen
            const maxSpeed = 1;
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > maxSpeed) {
                this.vx = (this.vx / speed) * maxSpeed;
                this.vy = (this.vy / speed) * maxSpeed;
            }
      }

      draw() {
        ctx.beginPath();
        if (this.shape === 'circle') {
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        } else if (this.shape === 'square') {
          ctx.rect(this.x - this.radius / 2, this.y - this.radius / 2, this.radius, this.radius);
        } else { // Triangle
          const side = this.radius * 2;
          const height = side * Math.sqrt(3) / 2;
          ctx.moveTo(this.x, this.y - height / 2);
          ctx.lineTo(this.x + side / 2, this.y + height / 2);
          ctx.lineTo(this.x - side / 2, this.y + height / 2);
          ctx.closePath();
        }
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }

     function createParticles() {
         particles.length = 0; // Limpiar array por si se llama de nuevo
         for (let i = 0; i < numParticles; i++) {
             // Asegurarse que no se creen dentro de la carta inicialmente
             let x, y, rect, dx, dy, distance;
              const maxAttempts = 10;
              let attempts = 0;
             do {
                x = Math.random() * canvas.width;
                y = Math.random() * canvas.height;
                rect = rotateCard.getBoundingClientRect(); // Usar la carta principal como referencia
                 dx = x - (rect.left + rect.width / 2);
                 dy = y - (rect.top + rect.height / 2);
                 distance = Math.sqrt(dx*dx + dy*dy);
                 attempts++;
             } while (distance < (rect.width / 2) * 1.5 && attempts < maxAttempts) // Evitar zona cercana a la carta

             particles.push(new Particle(x, y));
         }
     }

     let lastTime = 0;
     function animateParticles(currentTime) {
         const deltaTime = currentTime - lastTime;
         lastTime = currentTime;

         ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar canvas

         particles.forEach(particle => {
             particle.update(deltaTime); // Actualizar posición y velocidad
             particle.draw(); // Dibujar partícula
         });

         requestAnimationFrame(animateParticles); // Continuar animación
     }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
       // Recalcular partículas si cambia mucho el tamaño? Opcional.
       // Por ahora, no las recreamos al redimensionar.
    }

    // Inicialización
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    createParticles();
    lastTime = performance.now(); // Iniciar tiempo para deltaTime
    requestAnimationFrame(animateParticles); // Iniciar loop de animación de partículas


    // Limpieza de la función animate() duplicada y checkCollision que estaba separada
    // La lógica de colisión/interacción ahora está dentro de particle.update()

  </script>
</body>
</html>
